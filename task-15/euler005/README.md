# **Project Euler #5: Smallest multiple**
## **Method of Approach**
*I solved this problem on pen and paper first before coding it in Python. First thought coming to mind is the usage of n! But, the problem with n! is that A LOT of the numbers are repeated thus, making the value MUCH larger than required. So, all we have to do is eliminate the duplicates. Now, if the required number is divisible by all the numbers from 1 to N, then it will also be divisible for all the prime numbers from 1 to N. And prime numbers aren't the product of any previous numbers so, they won't repeat. I generated a list(nl) of all the numbers from 1 to N and implemented a sieve to seperate all the prime numbers into a list(pnl). I wanted to use the Sieve of Eratosthenes to do that but, I couldn't really understand the implementation of that in Python, so I wrote a much slower sieve. These two lists were generated for the largest inputs to make the execution time faster. I used a nlbuffer and pnlbuffer to perform operations for the given smaller testcases. I multiplied all the prime numbers and stored them in a variable called ans(I had to define a multiply() function to multiply the elements in the list, for some reason math.prod() wasn't working idk why). Now, the multiplication of composite numbers WITHOUT the duplicates. On pen and paper, I did this by keeping the product of all the primes in the numerator and each of the composite numbers in the denominator. I cancelled the numerator and denominator and whatever was left in the denominator would be multiplied to the ans containing the product of all the primes. This ensures that no composite number whatsoever would be repeated as I eliminated all the common factors before multiplying the denominator. I implemented this into Python by using Fraction() and appended the final ans to an answer list and printed it out one by one. I submitted this in PyPy3 as the sieve I wrote for separating the prime numbers was incredibly slow for very large numbers.* 
